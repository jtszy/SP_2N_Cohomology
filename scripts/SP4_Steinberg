using Pkg
Pkg.activate(normpath(joinpath(@__DIR__, "../")))
using LinearAlgebra
using SparseArrays
using JuMP
using SCS
using IntervalArithmetic
ENV["JULIA_NUM_THREADS"] = Sys.CPU_THREADS÷2
LinearAlgebra.BLAS.set_num_threads(Sys.CPU_THREADS÷2)

using Groups
using LowCohomologySOS

n = 4
sp4 = MatrixGroups.SymplecticGroup{n}(Int8)
a12, a21, b31, b42, b32, b13, b24, b23 = gens(sp4)


F_sp4_Steinberg = FreeGroup(8)
x_12, x_21, y_12, yt_12, z_1, z_2, zt_1, zt_2 = gens(F_sp4_Steinberg)

Steinberg_matrix = Dict()

Steinberg_matrix[x_12] = let mat = 1*Matrix(I, 4, 4)
    mat[1,2] = 1
    mat[4,3] = -1
    mat
end

Steinberg_matrix[x_21] = let mat = 1*Matrix(I, 4, 4)
    mat[2,1] = 1
    mat[3,4] = -1
    mat
end

Steinberg_matrix[y_12] = let mat = 1*Matrix(I, 4, 4)
    mat[1,4] = 1
    mat[2,3] = 1
    mat
end

Steinberg_matrix[z_1] = let mat = 1*Matrix(I, 4, 4)
    mat[1,3] = 1
    mat
end

Steinberg_matrix[z_2] = let mat = 1*Matrix(I, 4, 4)
    mat[2,4] = 1
    mat
end

Steinberg_matrix[yt_12] = transpose(Steinberg_matrix[y_12])

Steinberg_matrix[zt_1] = transpose(Steinberg_matrix[z_1])

Steinberg_matrix[zt_2] = transpose(Steinberg_matrix[z_2])


gens_sp4 = [gens(sp4); inv.(gens(sp4))]

Ball_4, sizes = Groups.wlmetric_ball(gens_sp4, radius = 4)

Steinberg_group = Dict()

for g in Ball_4
    for gen in keys(Steinberg_matrix)
        if MatrixGroups.matrix_repr(g) == Steinberg_matrix[gen]
            Steinberg_group[gen] = g
        end
    end
end

gens(sp4)
Steinberg_group
Steinberg_matrix



hom_Steinberg = let source = F_sp4_Steinberg, target = sp4
    function F(i, source, target)
        if source([i]) == one(F_sp4_Steinberg)
            return one(sp4)
        end
        for gen in keys(Steinberg_group)
            if source([i]) == gen
                return word(Steinberg_group[gen])
            elseif source([i]) == gen^(-1)
                return word(Steinberg_group[gen]^(-1))
            end
        end
    end
    Groups.Homomorphism(F, source, target)
end

function com(x,y)
    x*y*x^(-1)*y^(-1)
end

Steinberg_relations = [
    com(x_12, y_12) * z_1^(-2),
    com(x_21,y_12) * z_2^(-2),
    com(x_12, yt_12) * zt_2^(2),
    com(x_21,yt_12) * zt_1^(2),
    com(x_12, z_2) * (z_1 * y_12)^(-1),
    com(x_12, z_2) * (y_12 * z_1)^(-1),
    com(x_21, z_1) * (z_2 * y_12)^(-1),
    com(x_21, z_1) * (y_12 * z_2)^(-1),
    com(x_12, zt_1) * (zt_2 * yt_12^(-1))^(-1),
    com(x_12, zt_1) * (yt_12^(-1) * zt_2)^(-1),
    com(x_21, zt_2) * (zt_1 * yt_12^(-1))^(-1),
    com(x_21, zt_2) * (yt_12^(-1) * zt_1)^(-1),
    com(y_12, zt_1) * (x_21 * z_2^(-1))^(-1),
    com(y_12, zt_1) * (z_2^(-1) * x_21) ^(-1),
    com(y_12, zt_2) * (x_12 * z_1^(-1))^(-1),
    com(y_12, zt_2) * (z_1^(-1) * x_12)^(-1),
    com(yt_12, z_1) * (x_12^(-1) * zt_2^(-1))^(-1),
    com(yt_12, z_1) * (zt_2^(-1) * x_12^(-1)) ^(-1),
    com(yt_12, z_2) * (x_21^(-1) * zt_1^(-1))^(-1),
    com(yt_12, z_2) * (zt_1^(-1) * x_21^(-1))^(-1)
]

# for r in Steinberg_relations
#     @assert hom_Steinberg(r) == one(sp4)
# end

jacobian_matrix_Steinberg = LowCohomologySOS.jacobian_matrix(Steinberg_relations)
RF_n = parent(first(jacobian_matrix_Steinberg))

support_jacobian = union!(
    [one(sp4)],
    values(Steinberg_group),
    inv.(values(Steinberg_group))
)

for entry in jacobian_matrix_Steinberg
    for i in SparseArrays.nonzeroinds(entry.coeffs)
        push!(support_jacobian, hom_Steinberg(RF_n.basis[i]))
    end
end

support_jacobian = unique!([support_jacobian; inv.(support_jacobian)])
support_jacobian

Δ₁, I_4 = LowCohomologySOS.spectral_gap_elements(
    hom_Steinberg,
    Steinberg_relations,
    support_jacobian
)

sos_problem_Steinberg = LowCohomologySOS.sos_problem(
    Δ₁,
    I_4
)

function scs_opt(;
    accel = 10,
    alpha = 1.5,
    eps = 1e-9,
    max_iters = 6_000,
    verbose = true,
)
    return JuMP.optimizer_with_attributes(
        SCS.Optimizer,
        "acceleration_lookback" => accel,
        "acceleration_interval" => max(abs(accel), 1),
        "alpha" => alpha,
        "eps_abs" => eps,
        "eps_rel" => eps,
        "linear_solver" => SCS.DirectSolver,
        "max_iters" => max_iters,
        "warm_start" => true,
        "verbose" => verbose,
    )
end

JuMP.set_optimizer(sos_problem_Steinberg, scs_opt(eps = 1e-7, max_iters = 15000))

JuMP.optimize!(sos_problem_Steinberg)

λ, Q =  LowCohomologySOS.get_solution(sos_problem_Steinberg)

result_bool, result = LowCohomologySOS.certify_sos_decomposition(
    Δ₁,
    I,
    λ,
    Q,
    support_jacobian
)